# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SafeguardingBuilderDialog
                                 A QGIS plugin
 Generates NASF safeguarding layers based on a set of runway threshold coordinates
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-31
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Cam Todd
        email                : cam.todd@to70.com.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# safeguarding_builder_dialog.py
"""
Dialog class for the Safeguarding Builder QGIS plugin.
Handles user input for airport, ARP, and runway data,
dynamically adds/removes runway groups, and performs
real-time calculations for display.
"""

import functools
import math
import os
import json
# No 're' import was used, removed.

# --- QGIS Imports ---
from qgis.core import QgsMessageLog, Qgis, QgsPointXY # QgsProject not directly used here
# Ensure QtCore is imported for constants like Qt.AlignRight, Qt.StrongFocus
from qgis.PyQt import uic, QtWidgets, QtGui, QtCore
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox

# --- Constants for UI Placeholders/Messages ---
# Using constants improves maintainability and consistency
CALC_PLACEHOLDER = "(Calculated)"
NA_PLACEHOLDER = "N/A"
ENTER_COORDS_MSG = "Enter Coords"
INVALID_COORDS_MSG = "Invalid Coords"
CALC_ERROR_MSG = "Calc Error"
SAME_POINT_MSG = "Same Point"
NEAR_POINTS_MSG = "Near Points" # Indicates very close but non-identical points
WIDGET_MISSING_MSG = "Widget?" # Indicates a required UI widget was not found


# Load the UI class from the .ui file
FORM_CLASS, _ = uic.loadUiType(os.path.join(
        os.path.dirname(__file__), 'safeguarding_builder_dialog_base.ui'))

# Plugin-specific constant for logging within this module
DIALOG_LOG_TAG = 'SafeguardingBuilderDialog'


class SafeguardingBuilderDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super().__init__(parent)
        self.setupUi(self)

        self._runway_id_counter = 0
        self._active_runway_indices = set()

        # --- Scroll Area Setup ---
        scroll_content_widget = None
        if hasattr(self, 'scrollArea_runways'):
          if not self.scrollArea_runways.widgetResizable():
            QgsMessageLog.logMessage("Setting scrollArea_runways.widgetResizable = True", DIALOG_LOG_TAG, level=Qgis.Info)
            self.scrollArea_runways.setWidgetResizable(True)
          scroll_content_widget = self.scrollArea_runways.widget() # Usually scrollAreaWidgetContents
        else:
          QgsMessageLog.logMessage("Critical: scrollArea_runways not found in UI.", DIALOG_LOG_TAG, level=Qgis.Critical)

        self.scroll_area_layout = None
        if scroll_content_widget:
          # Ensure the widget inside scrollArea has a layout
          if not scroll_content_widget.layout():
            layout = QtWidgets.QVBoxLayout(scroll_content_widget)
            scroll_content_widget.setLayout(layout)
            QgsMessageLog.logMessage("Created default QVBoxLayout for scrollArea widget.", DIALOG_LOG_TAG, level=Qgis.Info)
          self.scroll_area_layout = scroll_content_widget.layout()
          # ### NOTE: Setting sizePolicy on scroll content widget is usually not needed when widgetResizable=True
          # scroll_content_widget.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Preferred)
          # QgsMessageLog.logMessage("Set sizePolicy for scroll area content widget.", DIALOG_LOG_TAG, level=Qgis.Info)
        else:
          QgsMessageLog.logMessage("Critical: Scroll area widget (e.g., scrollAreaWidgetContents) missing.", DIALOG_LOG_TAG, level=Qgis.Critical)

        # If layout still not found, disable add button
        if not self.scroll_area_layout:
          QgsMessageLog.logMessage("Critical: Scroll area layout could not be found or created.", DIALOG_LOG_TAG, level=Qgis.Critical)
          if hasattr(self, 'pushButton_add_runway'): self.pushButton_add_runway.setEnabled(False)


        # --- Setup Coordinate Validators ---
        # ### NOTE: Create ONE shared instance for coordinates
        self.coord_validator = QtGui.QDoubleValidator()
        self.coord_validator.setNotation(QtGui.QDoubleValidator.StandardNotation) # Allow decimals
        self._setup_arp_validators(self.coord_validator) # Pass the instance
        self._initialize_first_runway(self.coord_validator) # Pass the instance
        self._connect_global_controls()

        # --- Connect Action Buttons ---
        clear_button = self.findChild(QtWidgets.QPushButton, "pushButton_clear_all")
        save_button = self.findChild(QtWidgets.QPushButton, "pushButton_save_data")
        load_button = self.findChild(QtWidgets.QPushButton, "pushButton_load_data")

        if clear_button: clear_button.clicked.connect(self.clear_all_inputs)
        else: QgsMessageLog.logMessage("Warning: 'pushButton_clear_all' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)
        if save_button: save_button.clicked.connect(self.save_input_data)
        else: QgsMessageLog.logMessage("Warning: 'pushButton_save_data' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)
        if load_button: load_button.clicked.connect(self.load_input_data)
        else: QgsMessageLog.logMessage("Warning: 'pushButton_load_data' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)

        # --- Development/Testing Aid: Prefill Fields ---
        self._prefill_test_data()

        # --- Ensure initial size calculation happens after potential prefill ---
        # Using a singleShot timer ensures the event loop runs once, allowing layouts to settle
        QtCore.QTimer.singleShot(0, self._update_dialog_height)

    # =========================================================================
    # == Initialization Helper Methods
    # =========================================================================

    def _setup_arp_validators(self, validator: QtGui.QDoubleValidator):
        """Finds ARP widgets and applies the shared coordinate validator and tooltips."""
        # ### NOTE: Removed redundant logging
        arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
        arp_north_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_northing")

        if arp_east_le:
            arp_east_le.setValidator(validator)
            arp_east_le.setPlaceholderText("e.g., 455000.00")
            arp_east_le.setToolTip("Airport Reference Point (ARP) Easting Coordinate")
        else: QgsMessageLog.logMessage("Warning: QLineEdit 'lineEdit_arp_easting' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)

        if arp_north_le:
            arp_north_le.setValidator(validator)
            arp_north_le.setPlaceholderText("e.g., 5772000.00")
            arp_north_le.setToolTip("Airport Reference Point (ARP) Northing Coordinate")
        else: QgsMessageLog.logMessage("Warning: QLineEdit 'lineEdit_arp_northing' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)

    def _initialize_first_runway(self, coord_validator: QtGui.QDoubleValidator):
        """Finds, registers, connects signals, and sets up validators/properties for the initial runway group from the UI."""
        initial_runway_index = 1
        initial_runway_group = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{initial_runway_index}")

        if not initial_runway_group:
            QgsMessageLog.logMessage(f"Warning: Could not find initial 'groupBox_runway_{initial_runway_index}'.", DIALOG_LOG_TAG, level=Qgis.Warning)
            self._runway_id_counter = 0; return

        self._add_runway_index(initial_runway_index)
        # ### FIX: More concise logging
        QgsMessageLog.logMessage(f"Initialized runway index {initial_runway_index}. Active: {self._active_runway_indices}", DIALOG_LOG_TAG, level=Qgis.Info)

        # --- Find widgets for the initial runway ---
        # ### FIX: Correct widget type for designation
        desig_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{initial_runway_index}")
        suffix_combo = initial_runway_group.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{initial_runway_index}")
        thr_east_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{initial_runway_index}")
        thr_north_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{initial_runway_index}")
        rec_east_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{initial_runway_index}")
        rec_north_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{initial_runway_index}")
        remove_button = initial_runway_group.findChild(QtWidgets.QPushButton, f"pushButton_remove_runway_{initial_runway_index}")
        width_le = initial_runway_group.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{initial_runway_index}")
        arc_num_combo = initial_runway_group.findChild(QtWidgets.QComboBox, f"comboBox_arc_num_{initial_runway_index}")
        arc_let_combo = initial_runway_group.findChild(QtWidgets.QComboBox, f"comboBox_arc_let_{initial_runway_index}")
        type1_combo = initial_runway_group.findChild(QtWidgets.QComboBox, f"comboBox_type_desig1_{initial_runway_index}")
        type2_combo = initial_runway_group.findChild(QtWidgets.QComboBox, f"comboBox_type_desig2_{initial_runway_index}")

        essential_inputs = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le]
        if not all(essential_inputs):
             missing = [f"lineEdit_rwy_desig_{initial_runway_index}" if not desig_le else None,
                        f"comboBox_rwy_suffix_{initial_runway_index}" if not suffix_combo else None,
                        # ... add others similarly if needed ...
                       ]
             missing = [m for m in missing if m] # Filter out None
             QgsMessageLog.logMessage(f"Warning: Missing essential input widgets in initial group: {missing}", DIALOG_LOG_TAG, level=Qgis.Warning)

        # --- Connect input signals ---
        self._connect_runway_input_signals(
            initial_runway_index, desig_le, suffix_combo, thr_east_le,
            thr_north_le, rec_east_le, rec_north_le
        )

        # --- Connect remove button signal ---
        if remove_button:
            remove_button.clicked.connect(functools.partial(self.remove_runway_group, initial_runway_index))
        else: QgsMessageLog.logMessage(f"Warning: Could not find pushButton_remove_runway_{initial_runway_index}.", DIALOG_LOG_TAG, level=Qgis.Warning)

        # --- Setup validators ---
        self._setup_coordinate_validators_for_widgets(coord_validator,
            thr_east_le, thr_north_le, rec_east_le, rec_north_le
        )
        if desig_le:
            desig_validator = QtGui.QIntValidator(1, 36, self)
            desig_le.setValidator(desig_validator)
            # ### NOTE: Removed input mask setting here, rely on validator + focusPolicy
        if width_le:
             # ### FIX: Increased max width, consistent validator creation
             width_validator = QtGui.QDoubleValidator(0.0, 9999.99, 2, self)
             width_validator.setNotation(QtGui.QDoubleValidator.StandardNotation)
             width_le.setValidator(width_validator)

        # --- Set focus policies for initial ComboBoxes ---
        # ### FIX: Ensure this loop runs and sets policy
        combos_to_set = [suffix_combo, arc_num_combo, arc_let_combo, type1_combo, type2_combo]
        for combo in combos_to_set:
             if combo:
                  combo.setFocusPolicy(QtCore.Qt.StrongFocus)
             else:
                  # Log only once if any combo is missing
                  QgsMessageLog.logMessage(f"Warning: An initial ComboBox expected but not found (for StrongFocus). Check UI file.", DIALOG_LOG_TAG, level=Qgis.Warning)
                  break # No need to check others if one is missing

        # --- Set focus policy for initial Designation LineEdit ---
        # ### FIX: Ensure Designation also has correct focus policy if set in Designer
        # if desig_le and desig_le.focusPolicy() == QtCore.Qt.NoFocus:
        #    QgsMessageLog.logMessage(f"Warning: Correcting focusPolicy for lineEdit_rwy_desig_{initial_runway_index} to StrongFocus.", DIALOG_LOG_TAG, level=Qgis.Warning)
        #    desig_le.setFocusPolicy(QtCore.Qt.StrongFocus) # Or ClickFocus

        self._runway_id_counter = max(self._runway_id_counter, initial_runway_index)


    def _connect_global_controls(self):
        """Connects signals for global widgets like Airport Name and Add Runway button."""
        if hasattr(self, 'lineEdit_airport_name'):
            self.lineEdit_airport_name.textChanged.connect(self.update_all_runway_calculations)
        else: QgsMessageLog.logMessage("Warning: 'lineEdit_airport_name' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)

        if hasattr(self, 'pushButton_add_runway') and self.scroll_area_layout:
            self.pushButton_add_runway.clicked.connect(self.add_runway_group)
        elif not hasattr(self, 'pushButton_add_runway'): QgsMessageLog.logMessage("Warning: 'pushButton_add_runway' not found.", DIALOG_LOG_TAG, level=Qgis.Warning)
        elif not self.scroll_area_layout: QgsMessageLog.logMessage("Warning: 'pushButton_add_runway' not connected (layout missing).", DIALOG_LOG_TAG, level=Qgis.Warning)


    def _prefill_test_data(self):
        """Fills some fields with example data for easier testing during development."""
        # ### NOTE: Removed verbose logging
        try:
            icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
            if icao_le: icao_le.setText("YLTV")
            arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
            arp_north_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_northing")
            if arp_east_le: arp_east_le.setText("455050.12")
            if arp_north_le: arp_north_le.setText("5772150.34")

            runway_index_to_prefill = 1
            if runway_index_to_prefill in self._active_runway_indices:
                # ### FIX: Use LineEdit for designation
                desig_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{runway_index_to_prefill}")
                thr_east_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{runway_index_to_prefill}")
                thr_north_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{runway_index_to_prefill}")
                rec_east_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{runway_index_to_prefill}")
                rec_north_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{runway_index_to_prefill}")
                # ### FIX: Find width LineEdit for potential prefill (optional)
                # width_le = self.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{runway_index_to_prefill}")

                # ### FIX: Set text for LineEdit
                if desig_le: desig_le.setText("09")
                if thr_east_le: thr_east_le.setText("453195.143")
                if thr_north_le: thr_north_le.setText("5771292.337")
                if rec_east_le: rec_east_le.setText("454103.912")
                if rec_north_le: rec_north_le.setText("5771184.104")
                # if width_le: width_le.setText("30") # Example width prefill

                # Trigger update after potentially changing values that affect calculations
                self.update_all_runway_calculations()
                QgsMessageLog.logMessage(f"Prefilled data for Runway {runway_index_to_prefill}.", DIALOG_LOG_TAG, level=Qgis.Info)
            else: QgsMessageLog.logMessage(f"Skipping prefill for Runway {runway_index_to_prefill} (not found/active).", DIALOG_LOG_TAG, level=Qgis.Info)

        except Exception as e: QgsMessageLog.logMessage(f"ERROR during prefill: {e}", DIALOG_LOG_TAG, level=Qgis.Critical)

    # =========================================================================
    # == Runway Group Management
    # =========================================================================

    def _get_next_runway_id(self) -> int:
        """Generates the next unique ID for a new runway group."""
        self._runway_id_counter += 1
        return self._runway_id_counter

    def _add_runway_index(self, index: int):
        """Registers a runway index as active."""
        self._active_runway_indices.add(index)

    def _remove_runway_index(self, index: int):
        """Removes a runway index from the active set."""
        self._active_runway_indices.discard(index)

    # ### NOTE: Signature already updated to take lineEdit
    def _connect_runway_input_signals(self, runway_index: int, desig_lineEdit, suffix_combobox,
                                        thr_east_lineEdit, thr_north_lineEdit,
                                        rec_thr_east_lineEdit, rec_thr_north_lineEdit):
        """Connects input widget signals for a specific runway group to the update calculation method."""
        try:
            # ### FIX: Pass None as group_box_widget initially, update_runway_calculations will find it
            partial_update = functools.partial(self.update_runway_calculations, runway_index, None)

            # Connect signals if widgets exist
            if desig_lineEdit: desig_lineEdit.textChanged.connect(partial_update)
            if suffix_combobox: suffix_combobox.currentIndexChanged.connect(partial_update)
            if thr_east_lineEdit: thr_east_lineEdit.textChanged.connect(partial_update)
            if thr_north_lineEdit: thr_north_lineEdit.textChanged.connect(partial_update)
            if rec_thr_east_lineEdit: rec_thr_east_lineEdit.textChanged.connect(partial_update)
            if rec_thr_north_lineEdit: rec_thr_north_lineEdit.textChanged.connect(partial_update)
        except Exception as e: QgsMessageLog.logMessage(f"Error connecting input signals for runway {runway_index}: {e}", DIALOG_LOG_TAG, level=Qgis.Critical)

    def _setup_coordinate_validators_for_widgets(self, validator: QtGui.QDoubleValidator, *widgets):
        """Applies the provided QDoubleValidator to the given QLineEdit widgets."""
        # ### NOTE: Simplified logging
        for i, widget in enumerate(widgets):
            if widget and isinstance(widget, QtWidgets.QLineEdit):
                widget.setValidator(validator)
            # else: Log only if debugging needed

    def update_all_runway_calculations(self):
        """Calls update_runway_calculations for all currently active runway groups."""
        # ### NOTE: Removed verbose logging
        active_indices_copy = list(self._active_runway_indices)
        for index in active_indices_copy:
            group_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{index}")
            if group_box:
                # ### FIX: Pass the found group_box
                self.update_runway_calculations(index, group_box)
            else:
                QgsMessageLog.logMessage(f"Skipping update for index {index}, group box not found. Removing from active set.", DIALOG_LOG_TAG, level=Qgis.Warning)
                self._remove_runway_index(index)


    # ### NOTE: Signature already updated
    def update_runway_calculations(self, runway_index: int, group_box_widget: QtWidgets.QGroupBox = None):
        """
        Reads inputs, performs calculations (name, length, azimuth),
        and updates display labels for a specific runway group.
        Uses the provided group_box_widget if available.
        """
        # ### NOTE: Logic seems mostly correct from previous pass, keep as is.
        # Ensure findChild calls use group_box_widget where appropriate.

        # --- 1. Get GroupBox Widget ---
        if not group_box_widget:
            group_box_widget = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{runway_index}")
        if not group_box_widget:
            QgsMessageLog.logMessage(f"Cannot update calc for index {runway_index}, GroupBox not found or provided.", DIALOG_LOG_TAG, level=Qgis.Warning)
            return

        # --- 2. Find Required Widgets ---
        try:
            icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
            desig_le = group_box_widget.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{runway_index}")
            suffix_combo = group_box_widget.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{runway_index}")
            thr_east_le = group_box_widget.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{runway_index}")
            thr_north_le = group_box_widget.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{runway_index}")
            rec_east_le = group_box_widget.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{runway_index}")
            rec_north_le = group_box_widget.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{runway_index}")
            rec_desig_hdr_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_header_desig2_{runway_index}")
            rwy_name_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_rwy_name_{runway_index}")
            dist_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_rwy_distance_{runway_index}")
            azim_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_rwy_azimuth_{runway_index}")
            type1_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_type_desig1_{runway_index}")
            type2_lbl = group_box_widget.findChild(QtWidgets.QLabel, f"label_type_desig2_{runway_index}")

            # Check essential widgets
            input_widgets = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le]
            output_labels = [rec_desig_hdr_lbl, rwy_name_lbl, dist_lbl, azim_lbl, type1_lbl, type2_lbl]
            if not all(input_widgets + output_labels):
                 # Simplified missing widget logging
                 missing = [f"widget for runway {runway_index}" for w in (input_widgets + output_labels) if not w]
                 QgsMessageLog.logMessage(f"Warning: Missing essential {', '.join(missing)}. Calculations stopped.", DIALOG_LOG_TAG, level=Qgis.Warning)
                 # Keep setting outputs to error state...
                 if rec_desig_hdr_lbl: rec_desig_hdr_lbl.setText(WIDGET_MISSING_MSG)
                 if rwy_name_lbl: rwy_name_lbl.setText(WIDGET_MISSING_MSG)
                 if dist_lbl: dist_lbl.setText(WIDGET_MISSING_MSG)
                 if azim_lbl: azim_lbl.setText(WIDGET_MISSING_MSG)
                 if type1_lbl: type1_lbl.setText("Type 1:")
                 if type2_lbl: type2_lbl.setText("Type 2:")
                 return

        except Exception as e:
             QgsMessageLog.logMessage(f"Error finding widgets for runway {runway_index}: {e}", DIALOG_LOG_TAG, level=Qgis.Critical)
             # Attempt setting outputs (might fail if widgets missing)
             try:
                 if rec_desig_hdr_lbl: rec_desig_hdr_lbl.setText(WIDGET_MISSING_MSG)
                 # ...etc...
             except NameError: pass
             return

        # --- 3. Get Input Values ---
        icao_code = icao_le.text().strip().upper() if icao_le else ""
        rwy_desig_str = desig_le.text()
        rwy_suffix = suffix_combo.currentText()
        thr_east_str = thr_east_le.text().strip()
        thr_north_str = thr_north_le.text().strip()
        rec_thr_east_str = rec_east_le.text().strip()
        rec_thr_north_str = rec_north_le.text().strip()

        # --- 4. Perform Calculations ---
        # (Keep existing calculation logic - seems okay)
        reciprocal_desig_num_str = NA_PLACEHOLDER; reciprocal_suffix_str = ""; full_desig_1_str = "??"; full_desig_2_str = "??"; rwy_name_str = WIDGET_MISSING_MSG; distance_str = WIDGET_MISSING_MSG; azimuth_str = WIDGET_MISSING_MSG; type1_label_str = "Type 1:"; type2_label_str = "Type 2:"; rwy_desig_val = 0
        try:
            if not rwy_desig_str: raise ValueError("Designation empty")
            rwy_desig_val = int(rwy_desig_str)
            if not (1 <= rwy_desig_val <= 36): raise ValueError("Designation out of range (1-36)")
            full_desig_1_str = f"{rwy_desig_val:02d}{rwy_suffix}"
            type1_label_str = f"{full_desig_1_str} End Type:"
            reciprocal_val = (rwy_desig_val + 18) if rwy_desig_val <= 18 else (rwy_desig_val - 18)
            reciprocal_desig_num_str = f"{reciprocal_val:02d}"
            reciprocal_suffix_map = {"L": "R", "R": "L", "C": "C"}; reciprocal_suffix_str = reciprocal_suffix_map.get(rwy_suffix, "")
            full_desig_2_str = f"{reciprocal_desig_num_str}{reciprocal_suffix_str}"
            type2_label_str = f"{full_desig_2_str} End Type:"
        except ValueError as e:
             # QgsMessageLog.logMessage(f"Invalid designation '{rwy_desig_str}' for runway {runway_index}: {e}", DIALOG_LOG_TAG, level=Qgis.Info) # Less noisy log
             full_desig_2_str = "Invalid"; full_desig_1_str = "??"
             type1_label_str = "Type 1:"; type2_label_str = "Type 2:"

        if full_desig_1_str != "??" and full_desig_2_str != "Invalid" and full_desig_2_str != "??":
            base_rwy_name = f"Runway {full_desig_1_str}/{full_desig_2_str}"; rwy_name_str = f"{icao_code} {base_rwy_name}" if icao_code else base_rwy_name
        else: rwy_name_str = "Invalid Designation"

        coords_widgets_present = all([thr_east_le, thr_north_le, rec_east_le, rec_north_le]); coord_values_present = all([thr_east_str, thr_north_str, rec_thr_east_str, rec_thr_north_str])
        if not coords_widgets_present: distance_str, azimuth_str = WIDGET_MISSING_MSG, WIDGET_MISSING_MSG
        elif not coord_values_present: distance_str, azimuth_str = ENTER_COORDS_MSG, ENTER_COORDS_MSG
        else:
            try:
                # Coordinate validation - simplified check
                coords_to_validate = [thr_east_str, thr_north_str, rec_thr_east_str, rec_thr_north_str]
                for coord_str in coords_to_validate: float(coord_str) # Try conversion

                thr_east = float(thr_east_str); thr_north = float(thr_north_str); rec_thr_east = float(rec_thr_east_str); rec_thr_north = float(rec_thr_north_str)
                point1 = QgsPointXY(thr_east, thr_north); point2 = QgsPointXY(rec_thr_east, rec_thr_north)
                distance = point1.distance(point2); distance_str = f"{distance:.2f}"
                ZERO_TOLERANCE = 1e-6; NEAR_TOLERANCE = 0.1
                if math.isclose(distance, 0.0, abs_tol=ZERO_TOLERANCE):
                     azimuth_str = SAME_POINT_MSG; azimuth_str += f" (<{NEAR_TOLERANCE}m)" if distance > ZERO_TOLERANCE else ""
                else:
                    azimuth = point1.azimuth(point2); azimuth += 360 if azimuth < 0 else 0
                    azimuth_str = f"{azimuth:.2f}"; azimuth_str += f" ({NEAR_POINTS_MSG})" if distance < NEAR_TOLERANCE else ""
            except ValueError: distance_str, azimuth_str = INVALID_COORDS_MSG, INVALID_COORDS_MSG
            except Exception as e: QgsMessageLog.logMessage(f"Error during dist/azimuth calc for runway {runway_index}: {e}", DIALOG_LOG_TAG, level=Qgis.Warning); distance_str, azimuth_str = CALC_ERROR_MSG, CALC_ERROR_MSG

        # --- 5. Update Output Labels ---
        if rec_desig_hdr_lbl: rec_desig_hdr_lbl.setText(full_desig_2_str)
        if rwy_name_lbl: rwy_name_lbl.setText(rwy_name_str)
        if dist_lbl: dist_lbl.setText(distance_str)
        if azim_lbl: azim_lbl.setText(azimuth_str)
        if type1_lbl: type1_lbl.setText(type1_label_str)
        if type2_lbl: type2_lbl.setText(type2_label_str)

    # ### NOTE: Code for add_runway_group seems mostly correct from previous pass
    # Ensure all setFocusPolicy, setAlignment, setSizePolicy, setColumnStretch calls are present
    def add_runway_group(self):
      """Creates and adds a new group of widgets for an additional runway to the scroll area, using the grid layout."""
      if not self.scroll_area_layout:
        QgsMessageLog.logMessage("Cannot add runway group, scroll area layout not found.", DIALOG_LOG_TAG, level=Qgis.Critical)
        QtWidgets.QMessageBox.critical(self, "Error", "Cannot add runway: Dialog layout is missing or invalid.")
        return

      runway_index = self._get_next_runway_id()

      # --- Create Widgets Programmatically (New Layout) ---
      new_groupBox = QtWidgets.QGroupBox(f"Runway {runway_index}")
      new_groupBox.setObjectName(f"groupBox_runway_{runway_index}")
      new_groupBox.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred) # Set size policy

      groupBox_layout = QtWidgets.QVBoxLayout(new_groupBox)
      groupBox_layout.setObjectName(f"verticalLayout_runway_{runway_index}")

      # --- 1. Coordinate Input Grid ---
      gridLayout_Coords = QtWidgets.QGridLayout()
      gridLayout_Coords.setObjectName(f"gridLayout_Coords_{runway_index}")
      gridLayout_Coords.setColumnStretch(0, 0); gridLayout_Coords.setColumnStretch(1, 1); gridLayout_Coords.setColumnStretch(2, 1) # Set stretches

      # Row Headers
      label_designation_row = QtWidgets.QLabel("Designation:") # Simplified label text
      label_designation_row.setObjectName(f"label_designation_row_{runway_index}")
      label_designation_row.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter) # Align
      label_easting_row = QtWidgets.QLabel("Easting:")
      label_easting_row.setObjectName(f"label_easting_row_{runway_index}")
      label_easting_row.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter) # Align
      label_northing_row = QtWidgets.QLabel("Northing:")
      label_northing_row.setObjectName(f"label_northing_row_{runway_index}")
      label_northing_row.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter) # Align

      # Primary Designation Input (Row 0, Col 1)
      h_layout_desig_inputs = QtWidgets.QHBoxLayout()
      lineEdit_rwy_desig = QtWidgets.QLineEdit()
      lineEdit_rwy_desig.setObjectName(f"lineEdit_rwy_desig_{runway_index}")
      lineEdit_rwy_desig.setMaxLength(2); lineEdit_rwy_desig.setToolTip("Enter the 2-digit primary runway designation (01-36).")
      lineEdit_rwy_desig.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
      desig_validator = QtGui.QIntValidator(1, 36, self); lineEdit_rwy_desig.setValidator(desig_validator)
      # ### FIX: Ensure focus policy is appropriate (might not be needed if set in Designer template and works)
      # lineEdit_rwy_desig.setFocusPolicy(QtCore.Qt.StrongFocus)

      comboBox_rwy_suffix = QtWidgets.QComboBox()
      comboBox_rwy_suffix.setObjectName(f"comboBox_rwy_suffix_{runway_index}")
      comboBox_rwy_suffix.addItems(["", "L", "C", "R"]); comboBox_rwy_suffix.setToolTip("Runway suffix (Leave blank if none)")
      comboBox_rwy_suffix.setFocusPolicy(QtCore.Qt.StrongFocus) # Set focus policy
      comboBox_rwy_suffix.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
      h_layout_desig_inputs.addWidget(lineEdit_rwy_desig); h_layout_desig_inputs.addWidget(comboBox_rwy_suffix)

      # Reciprocal Designation Header (Row 0, Col 2) - Output Only
      label_header_desig2 = QtWidgets.QLabel(CALC_PLACEHOLDER)
      label_header_desig2.setObjectName(f"label_header_desig2_{runway_index}")
      label_header_desig2.setToolTip("Calculated reciprocal designation"); label_header_desig2.setAlignment(QtCore.Qt.AlignCenter)

      # Coordinate Inputs (Rows 1&2, Cols 1&2)
      lineEdit_thr_easting = QtWidgets.QLineEdit(); lineEdit_thr_easting.setObjectName(f"lineEdit_thr_easting_{runway_index}"); lineEdit_thr_easting.setPlaceholderText("e.g., 456789.12"); lineEdit_thr_easting.setToolTip("Easting coordinate of the primary threshold"); lineEdit_thr_easting.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
      lineEdit_thr_northing = QtWidgets.QLineEdit(); lineEdit_thr_northing.setObjectName(f"lineEdit_thr_northing_{runway_index}"); lineEdit_thr_northing.setPlaceholderText("e.g., 123456.78"); lineEdit_thr_northing.setToolTip("Northing coordinate of the primary threshold"); lineEdit_thr_northing.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
      lineEdit_reciprocal_thr_easting = QtWidgets.QLineEdit(); lineEdit_reciprocal_thr_easting.setObjectName(f"lineEdit_reciprocal_thr_easting_{runway_index}"); lineEdit_reciprocal_thr_easting.setPlaceholderText("e.g., 457890.34"); lineEdit_reciprocal_thr_easting.setToolTip("Easting coordinate of the reciprocal threshold"); lineEdit_reciprocal_thr_easting.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
      lineEdit_reciprocal_thr_northing = QtWidgets.QLineEdit(); lineEdit_reciprocal_thr_northing.setObjectName(f"lineEdit_reciprocal_thr_northing_{runway_index}"); lineEdit_reciprocal_thr_northing.setPlaceholderText("e.g., 124567.90"); lineEdit_reciprocal_thr_northing.setToolTip("Northing coordinate of the reciprocal threshold"); lineEdit_reciprocal_thr_northing.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)

      # Add widgets to Grid Layout
      gridLayout_Coords.addWidget(label_designation_row, 0, 0); gridLayout_Coords.addLayout(h_layout_desig_inputs, 0, 1); gridLayout_Coords.addWidget(label_header_desig2, 0, 2)
      gridLayout_Coords.addWidget(label_easting_row, 1, 0); gridLayout_Coords.addWidget(lineEdit_thr_easting, 1, 1); gridLayout_Coords.addWidget(lineEdit_reciprocal_thr_easting, 1, 2)
      gridLayout_Coords.addWidget(label_northing_row, 2, 0); gridLayout_Coords.addWidget(lineEdit_thr_northing, 2, 1); gridLayout_Coords.addWidget(lineEdit_reciprocal_thr_northing, 2, 2)
      groupBox_layout.addLayout(gridLayout_Coords)

      # --- 2. Runway Name ---
      label_rwy_name = QtWidgets.QLabel(CALC_PLACEHOLDER); label_rwy_name.setObjectName(f"label_rwy_name_{runway_index}"); groupBox_layout.addWidget(label_rwy_name)

      # --- 3. Details Form Layout ---
      formLayout_Details = QtWidgets.QFormLayout(); formLayout_Details.setObjectName(f"formLayout_Details_{runway_index}")
      formLayout_Details.setLabelAlignment(QtCore.Qt.AlignRight); formLayout_Details.setFieldGrowthPolicy(QtWidgets.QFormLayout.ExpandingFieldsGrow)

      # Calculated Length & Azimuth
      label_rwy_dist_text = QtWidgets.QLabel("Length (m):"); label_rwy_distance = QtWidgets.QLabel(CALC_PLACEHOLDER); label_rwy_distance.setObjectName(f"label_rwy_distance_{runway_index}"); formLayout_Details.addRow(label_rwy_dist_text, label_rwy_distance)
      label_rwy_azim_text = QtWidgets.QLabel("Azimuth (°):"); label_rwy_azimuth = QtWidgets.QLabel(CALC_PLACEHOLDER); label_rwy_azimuth.setObjectName(f"label_rwy_azimuth_{runway_index}"); formLayout_Details.addRow(label_rwy_azim_text, label_rwy_azimuth)

      # Runway Width Input
      label_runway_width = QtWidgets.QLabel("Runway Width (m):"); lineEdit_runway_width = QtWidgets.QLineEdit(); lineEdit_runway_width.setObjectName(f"lineEdit_runway_width_{runway_index}"); lineEdit_runway_width.setToolTip("Enter the actual runway width in meters."); lineEdit_runway_width.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed); width_validator = QtGui.QDoubleValidator(0.0, 9999.99, 2, self); width_validator.setNotation(QtGui.QDoubleValidator.StandardNotation); lineEdit_runway_width.setValidator(width_validator); formLayout_Details.addRow(label_runway_width, lineEdit_runway_width)

      # ARC Inputs
      label_arc_num = QtWidgets.QLabel("ARC Number:"); comboBox_arc_num = QtWidgets.QComboBox(); comboBox_arc_num.setObjectName(f"comboBox_arc_num_{runway_index}"); comboBox_arc_num.addItems(["", "1", "2", "3", "4"]); comboBox_arc_num.setToolTip("Select Aerodrome Reference Code Number (based on RFL)"); comboBox_arc_num.setFocusPolicy(QtCore.Qt.StrongFocus); formLayout_Details.addRow(label_arc_num, comboBox_arc_num)
      label_arc_let = QtWidgets.QLabel("ARC Letter:"); comboBox_arc_let = QtWidgets.QComboBox(); comboBox_arc_let.setObjectName(f"comboBox_arc_let_{runway_index}"); comboBox_arc_let.addItems(["", "A", "B", "C", "D", "E", "F"]); comboBox_arc_let.setToolTip("Select Aerodrome Reference Code Letter (based on wingspan/OMGWS)"); comboBox_arc_let.setFocusPolicy(QtCore.Qt.StrongFocus); formLayout_Details.addRow(label_arc_let, comboBox_arc_let)

      # Runway Type Inputs
      runway_types = ["", "Non-Instrument (NI)", "Non-Precision Approach (NPA)", "Precision Approach CAT I", "Precision Approach CAT II/III"]
      label_type_desig1 = QtWidgets.QLabel("(Primary End) Type:"); label_type_desig1.setObjectName(f"label_type_desig1_{runway_index}"); comboBox_type_desig1 = QtWidgets.QComboBox(); comboBox_type_desig1.setObjectName(f"comboBox_type_desig1_{runway_index}"); comboBox_type_desig1.addItems(runway_types); comboBox_type_desig1.setToolTip("Select the runway type for the primary designation end."); comboBox_type_desig1.setFocusPolicy(QtCore.Qt.StrongFocus); formLayout_Details.addRow(label_type_desig1, comboBox_type_desig1)
      label_type_desig2 = QtWidgets.QLabel("(Reciprocal End) Type:"); label_type_desig2.setObjectName(f"label_type_desig2_{runway_index}"); comboBox_type_desig2 = QtWidgets.QComboBox(); comboBox_type_desig2.setObjectName(f"comboBox_type_desig2_{runway_index}"); comboBox_type_desig2.addItems(runway_types); comboBox_type_desig2.setToolTip("Select the runway type for the reciprocal designation end."); comboBox_type_desig2.setFocusPolicy(QtCore.Qt.StrongFocus); formLayout_Details.addRow(label_type_desig2, comboBox_type_desig2)

      groupBox_layout.addLayout(formLayout_Details)

      # --- 4. Separator Line ---
      line_separator = QtWidgets.QFrame(); line_separator.setObjectName(f"line_runway_group_{runway_index}"); line_separator.setFrameShape(QtWidgets.QFrame.HLine); line_separator.setFrameShadow(QtWidgets.QFrame.Sunken); groupBox_layout.addWidget(line_separator)

      # --- 5. Remove Button ---
      removeButton = QtWidgets.QPushButton("Remove This Runway"); removeButton.setObjectName(f"pushButton_remove_runway_{runway_index}"); removeButton.setToolTip(f"Remove runway definition"); groupBox_layout.addWidget(removeButton)

      # --- Add new group to the scroll area layout ---
      # ### NOTE: Simplified the insertion logic slightly
      add_button_widget = self.findChild(QtWidgets.QPushButton, "pushButton_add_runway")
      insert_index = self.scroll_area_layout.indexOf(add_button_widget) if add_button_widget else -1
      if insert_index != -1:
          self.scroll_area_layout.insertWidget(insert_index, new_groupBox)
      else:
          # Fallback: Add at the end if button wasn't found in the layout
          self.scroll_area_layout.addWidget(new_groupBox)
          QgsMessageLog.logMessage(f"Warning: Add button not in scroll layout? Added group {runway_index} at end.", DIALOG_LOG_TAG, level=Qgis.Warning)

      # --- Register index and connect signals ---
      self._add_runway_index(runway_index)
      self._connect_runway_input_signals(
        runway_index, lineEdit_rwy_desig, comboBox_rwy_suffix, lineEdit_thr_easting,
        lineEdit_thr_northing, lineEdit_reciprocal_thr_easting, lineEdit_reciprocal_thr_northing
      )
      removeButton.clicked.connect(functools.partial(self.remove_runway_group, runway_index))

      # --- Add Coordinate Validators ---
      # ### NOTE: Use the shared instance variable self.coord_validator
      if self.coord_validator:
        self._setup_coordinate_validators_for_widgets(self.coord_validator,
          lineEdit_thr_easting, lineEdit_thr_northing,
          lineEdit_reciprocal_thr_easting, lineEdit_reciprocal_thr_northing
        )
      else: QgsMessageLog.logMessage(f"CRITICAL: Shared coordinate validator missing for runway {runway_index}.", DIALOG_LOG_TAG, level=Qgis.Critical)

      # --- Trigger initial calculation ---
      # ### FIX: Pass the newly created group box
      self.update_runway_calculations(runway_index, new_groupBox)

      # --- Update Dialog Size ---
      self._update_dialog_height()


    # ### NOTE: remove_runway_group, _update_dialog_height, _remove_runway_group_internal remain unchanged, seem okay.
    def remove_runway_group(self, runway_index_to_remove: int):
      """Finds and removes the specified runway group box after user confirmation, with context-specific message."""
      QgsMessageLog.logMessage(f"Attempting to remove runway index {runway_index_to_remove}. Active: {self._active_runway_indices}", DIALOG_LOG_TAG, level=Qgis.Info)
      
      if runway_index_to_remove not in self._active_runway_indices:
        QgsMessageLog.logMessage(f"Cannot remove: Index {runway_index_to_remove} is not in active set.", DIALOG_LOG_TAG, level=Qgis.Warning)
        return
      
      # --- Determine the runway name for the message ---
      runway_display_name = None # Store the descriptive name if found
      has_descriptive_name = False # Flag to track if we found a better name
      
      groupBox_to_remove = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{runway_index_to_remove}")
      if groupBox_to_remove:
        # Try to get a more descriptive name if possible
        name_label = groupBox_to_remove.findChild(QtWidgets.QLabel, f"label_rwy_name_{runway_index_to_remove}")
        # Check if label exists AND has valid, non-placeholder text
        placeholders_to_ignore = [CALC_PLACEHOLDER, WIDGET_MISSING_MSG, "", None, "Invalid Designation"]
        if name_label and name_label.text() not in placeholders_to_ignore:
          runway_display_name = name_label.text() # Store the better name
          has_descriptive_name = True             # Set the flag
          
      # --- Construct the confirmation message conditionally --- <--- PLACEMENT START
      if has_descriptive_name:
        # Use the descriptive name found
        confirmation_message = self.tr("Are you sure you want to remove this runway? ({runway_name})?").format(runway_name=runway_display_name)
      else:
        # Use the generic message
        confirmation_message = self.tr("Are you sure you want to remove this runway?")
      # --- Construct the confirmation message conditionally --- <--- PLACEMENT END
        
      # --- Confirm removal with the user ---
      reply = QtWidgets.QMessageBox.question(self,
                        self.tr('Confirm Removal'), # Use tr for title
                        confirmation_message,      # Use the constructed message
                        QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                        QtWidgets.QMessageBox.No)
      
      if reply == QtWidgets.QMessageBox.Yes:
        self._remove_runway_group_internal(runway_index_to_remove)
        # Logging moved to internal function
      # else: User clicked No, do nothing

    def _remove_runway_group_internal(self, runway_index: int):
      """Internal helper to remove a group without user confirmation. Also called by clear_all."""
      # Find the GroupBox widget to remove
      groupBox_to_remove = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{runway_index}")
      
      if groupBox_to_remove and self.scroll_area_layout:
        # Remove widget from layout management and schedule for deletion
        # Hiding first might prevent brief visual glitches
        groupBox_to_remove.hide()
        self.scroll_area_layout.removeWidget(groupBox_to_remove)
        groupBox_to_remove.deleteLater() # Crucial: schedules deletion when safe
        
        # Update internal tracking *after* scheduling deletion
        self._remove_runway_index(runway_index)
        QgsMessageLog.logMessage(f"Internal removal: Removed group {runway_index}. Active: {self._active_runway_indices}", DIALOG_LOG_TAG, level=Qgis.Info)
        
        # Update Dialog Size after removing the group
        self._update_dialog_height()
        
      elif not groupBox_to_remove:
        # Group was in active set but widget not found - indicates inconsistency
        QgsMessageLog.logMessage(f"Internal removal Warning: Could not find widget for index {runway_index} despite it being active. Cleaning up tracking.", DIALOG_LOG_TAG, level=Qgis.Warning)
        self._remove_runway_index(runway_index) # Ensure tracking is consistent
      elif not self.scroll_area_layout:
        # Should have been caught earlier, but double-check
        QgsMessageLog.logMessage(f"Internal removal Critical Error: Cannot remove group {runway_index}, scroll area layout is missing.", DIALOG_LOG_TAG, level=Qgis.Critical)

    def _update_dialog_height(self):
      """Adjusts the dialog height to fit its contents."""
      # QgsMessageLog.logMessage("Updating dialog height...", DIALOG_LOG_TAG, level=Qgis.Info) # Optional debug
      # Trigger dialog resize based on its children's size hints
      # This method relies on layouts and size policies being set correctly.
      if hasattr(self, 'scrollArea_runways'):
        self.adjustSize()
      # else: Log only if debugging needed


    # =========================================================================
    # == Action Button Handlers
    # =========================================================================

    # ### NOTE: clear_all_inputs seems okay, ensures correct call to update_runway_calculations
    def clear_all_inputs(self, confirm: bool = True) -> None:
      """Clears all input fields and removes dynamically added runway groups."""
      if confirm:
        reply = QMessageBox.question(self, self.tr('Confirm Clear'), # Use tr
                      self.tr("Are you sure you want to clear all inputs and remove added runways?"),
                      QMessageBox.Yes | QMessageBox.No,
                      QMessageBox.No)
        if reply == QMessageBox.No:
          return
        
      QgsMessageLog.logMessage("Clearing all dialog inputs.", DIALOG_LOG_TAG, level=Qgis.Info)
      
      # Clear global fields
      icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
      arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
      arp_north_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_northing")
      if icao_le: icao_le.clear()
      if arp_east_le: arp_east_le.clear()
      if arp_north_le: arp_north_le.clear()
      
      # --- Remove dynamically added runway groups (indices > 1) ---
      # ### FIX: Added logging before removal loop
      QgsMessageLog.logMessage(f"Clear All: Active indices BEFORE dynamic removal: {self._active_runway_indices}", DIALOG_LOG_TAG, level=Qgis.Info)
      indices_to_remove = [idx for idx in self._active_runway_indices if idx > 1]
      QgsMessageLog.logMessage(f"Clear All: Indices to remove (dynamic): {indices_to_remove}", DIALOG_LOG_TAG, level=Qgis.Info)
      for index in indices_to_remove:
        self._remove_runway_group_internal(index) # This calls _update_dialog_height
        
      # --- Clear the fields of the first runway group (index 1) if it exists ---
      runway_index_1 = 1
      initial_group_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{runway_index_1}")
      runway1_cleared = False # Flag to track if group 1 was processed
      if initial_group_box and runway_index_1 in self._active_runway_indices: # Check if it's still considered active
        # Find widgets
        desig_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{runway_index_1}")
        # ... find all other widgets ...
        suffix_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{runway_index_1}")
        thr_east_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{runway_index_1}")
        thr_north_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{runway_index_1}")
        rec_east_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{runway_index_1}")
        rec_north_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{runway_index_1}")
        width_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{runway_index_1}")
        arc_num_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_num_{runway_index_1}")
        arc_let_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_let_{runway_index_1}")
        type1_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig1_{runway_index_1}")
        type2_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig2_{runway_index_1}")
      
        blocked_widgets = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le,
            width_le, arc_num_combo, arc_let_combo, type1_combo, type2_combo]
      
        # Block signals temporarily
        for w in blocked_widgets:
          if w: w.blockSignals(True)
        # Clear fields
        if desig_le: desig_le.setText("")
        if suffix_combo: suffix_combo.setCurrentIndex(0)
        if thr_east_le: thr_east_le.clear()
        if thr_north_le: thr_north_le.clear()
        if rec_east_le: rec_east_le.clear()
        if rec_north_le: rec_north_le.clear()
        if width_le: width_le.clear()
        if arc_num_combo: arc_num_combo.setCurrentIndex(0)
        if arc_let_combo: arc_let_combo.setCurrentIndex(0)
        if type1_combo: type1_combo.setCurrentIndex(0)
        if type2_combo: type2_combo.setCurrentIndex(0)
        # Unblock signals
        for w in blocked_widgets:
          if w: w.blockSignals(False)
          
        # Update calculations for the cleared first runway
        self.update_runway_calculations(runway_index_1, initial_group_box)
        QgsMessageLog.logMessage(f"Clear All: Cleared fields for runway index {runway_index_1}.", DIALOG_LOG_TAG, level=Qgis.Info)
        runway1_cleared = True
      
      # --- Reset internal state AFTER potentially clearing group 1 ---
      if runway1_cleared:
        # Keep index 1 as the base if it existed and was cleared
        self._active_runway_indices = {runway_index_1}
        self._runway_id_counter = runway_index_1 # Reset counter to the last *kept* index
        QgsMessageLog.logMessage(f"Clear All: Reset state, keeping runway 1.", DIALOG_LOG_TAG, level=Qgis.Info)
      else:
        # If group 1 didn't exist or wasn't processed, clear everything
        self._active_runway_indices = set()
        self._runway_id_counter = 0
        QgsMessageLog.logMessage(f"Clear All: Reset state to empty (Runway 1 not found/cleared).", DIALOG_LOG_TAG, level=Qgis.Info)
        
      # ### FIX: Ensure dialog resizes after potential removals
      self._update_dialog_height()
      QgsMessageLog.logMessage(f"Clear All: Final state - Indices: {self._active_runway_indices}, Counter: {self._runway_id_counter}", DIALOG_LOG_TAG, level=Qgis.Info)
      
      # ### NOTE: save_input_data seems okay, includes new fields
    def save_input_data(self):
        """Gathers current inputs and saves them to a JSON file."""
        # ### FIX: Added entry log
        QgsMessageLog.logMessage("Save button clicked. Attempting to save...", DIALOG_LOG_TAG, level=Qgis.Info)
      
        # Suggest a filename based on ICAO code
        icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
        icao_code = icao_le.text().strip().upper() if icao_le else ""
        suggested_filename = f"{icao_code}_safeguarding_inputs.json" if icao_code else "safeguarding_inputs.json"
      
        # Ask user for save location
        file_path, _ = QFileDialog.getSaveFileName(self, self.tr("Save Safeguarding Inputs"), suggested_filename, self.tr("JSON Files (*.json)"))
      
        # ### FIX: Added logging after file dialog
        QgsMessageLog.logMessage(f"Save file path selected: '{file_path}'", DIALOG_LOG_TAG, level=Qgis.Info)
      
        if not file_path:
            QgsMessageLog.logMessage("Save cancelled by user.", DIALOG_LOG_TAG, level=Qgis.Info)
            return # User cancelled
      
        # Ensure file has .json extension
        if not file_path.lower().endswith(".json"):
             file_path += ".json"
             QgsMessageLog.logMessage(f"Appended .json extension: '{file_path}'", DIALOG_LOG_TAG, level=Qgis.Info)
          
        # --- Gather Data ---
        data_to_save = {}
        runway_list = []
      
        # Global Data
        arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
        arp_north_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_northing")
        data_to_save["icao_code"] = icao_code
        data_to_save["arp_easting"] = arp_east_le.text() if arp_east_le else ""
        data_to_save["arp_northing"] = arp_north_le.text() if arp_north_le else ""
      
        # Runway Data
        # ### FIX: Added logging before loop
        active_indices_to_save = sorted(list(self._active_runway_indices))
        QgsMessageLog.logMessage(f"Saving data for active runway indices: {active_indices_to_save}", DIALOG_LOG_TAG, level=Qgis.Info)
      
        for index in active_indices_to_save:
          runway_data = {}
          group_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{index}")
          if not group_box:
            QgsMessageLog.logMessage(f"Save Warning: Skipping index {index}, GroupBox missing.", DIALOG_LOG_TAG, level=Qgis.Warning)
            continue
          
          # Find widgets... (keep existing findChild logic)
          desig_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{index}")
          suffix_combo = group_box.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{index}")
          thr_east_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{index}")
          thr_north_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{index}")
          rec_east_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{index}")
          rec_north_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{index}")
          width_le = group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{index}")
          arc_num_combo = group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_num_{index}")
          arc_let_combo = group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_let_{index}")
          type1_combo = group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig1_{index}")
          type2_combo = group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig2_{index}")
          
          essential_widgets = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le, width_le, arc_num_combo, arc_let_combo, type1_combo, type2_combo]
          if not all(essential_widgets):
            # ### FIX: Improved missing widget log
            missing_names = [ew.objectName() for ew in essential_widgets if not ew]
            QgsMessageLog.logMessage(f"Save Warning: Skipping index {index}, missing widgets: {missing_names}.", DIALOG_LOG_TAG, level=Qgis.Warning)
            continue
          
          # Get values... (keep existing get value logic)
          runway_data["designator_str"] = desig_le.text()
          runway_data["suffix"] = suffix_combo.currentText()
          runway_data["thr_easting"] = thr_east_le.text()
          runway_data["thr_northing"] = thr_north_le.text()
          runway_data["rec_easting"] = rec_east_le.text()
          runway_data["rec_northing"] = rec_north_le.text()
          runway_data["width"] = width_le.text()
          runway_data["arc_num"] = arc_num_combo.currentText()
          runway_data["arc_let"] = arc_let_combo.currentText()
          runway_data["type1"] = type1_combo.currentText()
          runway_data["type2"] = type2_combo.currentText()
          runway_list.append(runway_data)
          # QgsMessageLog.logMessage(f"Saved data for index {index}", DIALOG_LOG_TAG, level=Qgis.Info) # Optional debug
          
        data_to_save["runways"] = runway_list
      
        # --- Write to JSON File ---
        try:
            # QgsMessageLog.logMessage(f"Attempting to write data to: {file_path}", DIALOG_LOG_TAG, level=Qgis.Info) # Optional debug
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data_to_save, f, indent=4)
            QgsMessageLog.logMessage(f"Successfully saved input data to: {file_path}", DIALOG_LOG_TAG, level=Qgis.Info)
            QMessageBox.information(self, self.tr("Save Successful"), self.tr("Input data saved to:\n{path}").format(path=file_path))
        except (IOError, TypeError, PermissionError, Exception) as e: # Catch broader exceptions
            error_msg = self.tr("Error saving data to {path}:").format(path=file_path) + f"\n{e}"
            QgsMessageLog.logMessage(error_msg, DIALOG_LOG_TAG, level=Qgis.Critical)
            QMessageBox.critical(self, self.tr("Save Error"), error_msg)

    # ### NOTE: load_input_data seems okay, ensures correct calls to update_runway_calculations
      
    def load_input_data(self):
        """Loads safeguarding inputs from a JSON file, replacing current dialog content."""
        # --- Confirm overwrite if data potentially exists ---
        icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
        arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
        has_global_data = (icao_le and icao_le.text()) or (arp_east_le and arp_east_le.text())
        has_runway_data = False
        if len(self._active_runway_indices) > 1:
              has_runway_data = True
        elif 1 in self._active_runway_indices:
              # Check if any core input field in group 1 has data
              group1_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_1")
              if group1_box:
                  thr_east_le_1 = group1_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_1")
                  desig_le_1 = group1_box.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_1")
                  if (thr_east_le_1 and thr_east_le_1.text()) or (desig_le_1 and desig_le_1.text()):
                        has_runway_data = True
                    
        if has_global_data or has_runway_data:
            reply = QMessageBox.question(self, self.tr('Confirm Load'), # Use tr
                                        self.tr("Loading data will overwrite current inputs. Continue?"),
                                        QMessageBox.Yes | QMessageBox.No,
                                        QMessageBox.No)
            if reply == QMessageBox.No:
                QgsMessageLog.logMessage("Load cancelled by user confirmation.", DIALOG_LOG_TAG, level=Qgis.Info)
                return
          
        # --- Ask user for file ---
        file_path, _ = QFileDialog.getOpenFileName(self, self.tr("Load Safeguarding Inputs"), "", self.tr("JSON Files (*.json)"))
        if not file_path:
          QgsMessageLog.logMessage("Load cancelled by user (File Dialog).", DIALOG_LOG_TAG, level=Qgis.Info)
          return
      
        QgsMessageLog.logMessage(f"Attempting to load data from: {file_path}", DIALOG_LOG_TAG, level=Qgis.Info)
        loaded_data = None
      
        try: # --- Main Try Block ---
          # --- Read and Parse JSON ---
          with open(file_path, 'r', encoding='utf-8') as f:
            loaded_data = json.load(f)
            
          # --- Basic Validation ---
          if not isinstance(loaded_data, dict): raise ValueError("Invalid file: Top level not dict.")
          required_global_keys = ["icao_code", "arp_easting", "arp_northing", "runways"]
          if not all(key in loaded_data for key in required_global_keys):
                missing = [k for k in required_global_keys if k not in loaded_data]; raise ValueError(f"Invalid file: Missing keys: {missing}.")
          if not isinstance(loaded_data.get("runways"), list): raise ValueError("Invalid file: 'runways' not list.")
      
          # --- Clear Current Dialog State ---
          self.clear_all_inputs(confirm=False)
          QgsMessageLog.logMessage("Load: Dialog cleared, proceeding to populate.", DIALOG_LOG_TAG, level=Qgis.Info)
      
          # --- Populate Dialog ---
          # Global Fields
          icao_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_airport_name")
          arp_east_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_easting")
          arp_north_le = self.findChild(QtWidgets.QLineEdit, "lineEdit_arp_northing")
          if icao_le: icao_le.setText(loaded_data.get("icao_code", ""))
          if arp_east_le: arp_east_le.setText(loaded_data.get("arp_easting", ""))
          if arp_north_le: arp_north_le.setText(loaded_data.get("arp_northing", ""))
      
          # Runway Fields
          loaded_runways_list = loaded_data.get("runways", [])
          runway_index_1 = 1
          # Re-find group box after clearing
          initial_group_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{runway_index_1}")
      
          if not loaded_runways_list:
              QgsMessageLog.logMessage("Load: No runways found in loaded data.", DIALOG_LOG_TAG, level=Qgis.Info)
              if initial_group_box and runway_index_1 in self._active_runway_indices:
                  self.update_runway_calculations(runway_index_1, initial_group_box)
          else:
              # --- Populate first runway ---
              if initial_group_box and runway_index_1 in self._active_runway_indices:
                  first_runway_data = loaded_runways_list[0]
                  QgsMessageLog.logMessage(f"Load Group 1: Data Dict = {first_runway_data}", DIALOG_LOG_TAG, level=Qgis.Info)
                
                  # Find widgets for group 1
                  desig_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{runway_index_1}")
                  suffix_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{runway_index_1}")
                  thr_east_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{runway_index_1}")
                  thr_north_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{runway_index_1}")
                  rec_east_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{runway_index_1}")
                  rec_north_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{runway_index_1}")
                  width_le = initial_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{runway_index_1}")
                  arc_num_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_num_{runway_index_1}")
                  arc_let_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_let_{runway_index_1}")
                  type1_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig1_{runway_index_1}")
                  type2_combo = initial_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig2_{runway_index_1}")
                
                  blocked_widgets = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le, width_le, arc_num_combo, arc_let_combo, type1_combo, type2_combo]
                
                  try: # Try block for populating group 1
                      # Block signals
                      for w in blocked_widgets:
                          if w:
                              w.blockSignals(True)
                            
                      # === Populate Group 1 Widgets (WITH LOGGING) ===
                      val = first_runway_data.get("designator_str", ""); QgsMessageLog.logMessage(f"Load G1: Read Desig='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if desig_le: desig_le.setText(val)
                      val = first_runway_data.get("suffix", ""); QgsMessageLog.logMessage(f"Load G1: Read Suffix='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if suffix_combo: idx = suffix_combo.findText(val); suffix_combo.setCurrentIndex(idx if idx >= 0 else 0)
                      val = first_runway_data.get("thr_easting", ""); QgsMessageLog.logMessage(f"Load G1: Read ThrE='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if thr_east_le: thr_east_le.setText(val)
                      val = first_runway_data.get("thr_northing", ""); QgsMessageLog.logMessage(f"Load G1: Read ThrN='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if thr_north_le: thr_north_le.setText(val)
                      val = first_runway_data.get("rec_easting", ""); QgsMessageLog.logMessage(f"Load G1: Read RecE='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if rec_east_le: rec_east_le.setText(val)
                      val = first_runway_data.get("rec_northing", ""); QgsMessageLog.logMessage(f"Load G1: Read RecN='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if rec_north_le: rec_north_le.setText(val)
                      val = first_runway_data.get("width", ""); QgsMessageLog.logMessage(f"Load G1: Read Width='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if width_le: width_le.setText(val)
                      val = first_runway_data.get("arc_num", ""); QgsMessageLog.logMessage(f"Load G1: Read ArcNum='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if arc_num_combo: idx = arc_num_combo.findText(val); arc_num_combo.setCurrentIndex(idx if idx >= 0 else 0)
                      val = first_runway_data.get("arc_let", ""); QgsMessageLog.logMessage(f"Load G1: Read ArcLet='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if arc_let_combo: idx = arc_let_combo.findText(val); arc_let_combo.setCurrentIndex(idx if idx >= 0 else 0)
                      val = first_runway_data.get("type1", ""); QgsMessageLog.logMessage(f"Load G1: Read Type1='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if type1_combo: idx = type1_combo.findText(val); type1_combo.setCurrentIndex(idx if idx >= 0 else 0)
                      val = first_runway_data.get("type2", ""); QgsMessageLog.logMessage(f"Load G1: Read Type2='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                      if type2_combo: idx = type2_combo.findText(val); type2_combo.setCurrentIndex(idx if idx >= 0 else 0)
                
                  except Exception as e_pop1:
                      QgsMessageLog.logMessage(f"Load Error during population of group 1: {e_pop1}", DIALOG_LOG_TAG, level=Qgis.Warning)
                  finally:
                      # ### FIX: Unblock signals correctly ###
                      for w in blocked_widgets:
                          if w:
                              w.blockSignals(False) # Use False to unblock
                            
                  # Update calculations AFTER population and unblocking
                  self.update_runway_calculations(runway_index_1, initial_group_box)
                
              elif loaded_runways_list: # If group 1 missing but data exists
                    QgsMessageLog.logMessage(f"Load Warning: Initial group missing, cannot populate first runway.", DIALOG_LOG_TAG, level=Qgis.Warning)
            
              # --- Add and populate remaining runways ---
              for i, runway_data_item in enumerate(loaded_runways_list[1:], start=1):
                  try: # Try block for adding AND populating this specific runway
                      self.add_runway_group()
                      new_index = self._runway_id_counter
                      new_group_box = self.findChild(QtWidgets.QGroupBox, f"groupBox_runway_{new_index}")
                      if not new_group_box:
                          QgsMessageLog.logMessage(f"Load Error: Failed find newly added group {new_index}. Skipping item {i+1}.", DIALOG_LOG_TAG, level=Qgis.Warning)
                          continue
                
                      QgsMessageLog.logMessage(f"Load Group {new_index}: Data Dict = {runway_data_item}", DIALOG_LOG_TAG, level=Qgis.Info)
                
                      # Find widgets in the NEW group
                      desig_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_rwy_desig_{new_index}")
                      suffix_combo = new_group_box.findChild(QtWidgets.QComboBox, f"comboBox_rwy_suffix_{new_index}")
                      thr_east_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_easting_{new_index}")
                      thr_north_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_thr_northing_{new_index}")
                      rec_east_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_easting_{new_index}")
                      rec_north_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_reciprocal_thr_northing_{new_index}")
                      width_le = new_group_box.findChild(QtWidgets.QLineEdit, f"lineEdit_runway_width_{new_index}")
                      arc_num_combo = new_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_num_{new_index}")
                      arc_let_combo = new_group_box.findChild(QtWidgets.QComboBox, f"comboBox_arc_let_{new_index}")
                      type1_combo = new_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig1_{new_index}")
                      type2_combo = new_group_box.findChild(QtWidgets.QComboBox, f"comboBox_type_desig2_{new_index}")
                
                      blocked_widgets = [desig_le, suffix_combo, thr_east_le, thr_north_le, rec_east_le, rec_north_le, width_le, arc_num_combo, arc_let_combo, type1_combo, type2_combo]
                
                      try: # Inner try for populating this specific group
                          # Block signals
                          for w in blocked_widgets:
                              if w:
                                  w.blockSignals(True)
                                
                          # === Populate Group new_index Widgets (WITH LOGGING) ===
                          val = runway_data_item.get("designator_str", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read Desig='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if desig_le: desig_le.setText(val)
                          val = runway_data_item.get("suffix", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read Suffix='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if suffix_combo: idx = suffix_combo.findText(val); suffix_combo.setCurrentIndex(idx if idx >= 0 else 0)
                          val = runway_data_item.get("thr_easting", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read ThrE='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if thr_east_le: thr_east_le.setText(val)
                          val = runway_data_item.get("thr_northing", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read ThrN='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if thr_north_le: thr_north_le.setText(val)
                          val = runway_data_item.get("rec_easting", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read RecE='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if rec_east_le: rec_east_le.setText(val)
                          val = runway_data_item.get("rec_northing", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read RecN='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if rec_north_le: rec_north_le.setText(val)
                          val = runway_data_item.get("width", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read Width='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if width_le: width_le.setText(val)
                          val = runway_data_item.get("arc_num", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read ArcNum='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if arc_num_combo: idx = arc_num_combo.findText(val); arc_num_combo.setCurrentIndex(idx if idx >= 0 else 0)
                          val = runway_data_item.get("arc_let", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read ArcLet='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if arc_let_combo: idx = arc_let_combo.findText(val); arc_let_combo.setCurrentIndex(idx if idx >= 0 else 0)
                          val = runway_data_item.get("type1", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read Type1='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if type1_combo: idx = type1_combo.findText(val); type1_combo.setCurrentIndex(idx if idx >= 0 else 0)
                          val = runway_data_item.get("type2", ""); QgsMessageLog.logMessage(f"Load G{new_index}: Read Type2='{val}'", DIALOG_LOG_TAG, level=Qgis.Info);
                          if type2_combo: idx = type2_combo.findText(val); type2_combo.setCurrentIndex(idx if idx >= 0 else 0)
                
                      except Exception as e_pop_n:
                          QgsMessageLog.logMessage(f"Load Error during population of group {new_index}: {e_pop_n}", DIALOG_LOG_TAG, level=Qgis.Warning)
                      finally:
                          # ### FIX: Unblock signals correctly ###
                          for w in blocked_widgets:
                              if w:
                                  w.blockSignals(False) # Use False to unblock
                                
                      # Update calculations AFTER population and unblocking
                      self.update_runway_calculations(new_index, new_group_box)
                
                  except Exception as e_loop: # Catch errors during add_runway_group or finding widgets
                      QgsMessageLog.logMessage(f"Load Error processing runway item {i+1}: {e_loop}", DIALOG_LOG_TAG, level=Qgis.Warning)
                      continue # Try next runway
            
          # --- End of runway processing ---
          QMessageBox.information(self, self.tr("Load Successful"), self.tr("Input data loaded from:\n{path}").format(path=file_path))
      
        # --- Outer Exception Handling ---
        except (IOError, json.JSONDecodeError, ValueError, KeyError, Exception) as load_error:
              error_details = f"{type(load_error).__name__}: {load_error}"
              log_msg = f"Error loading data from {file_path}: {error_details}" # file_path guaranteed to exist here
              user_msg = self.tr("Could not load data from file.") + f"\n{file_path}\n\n{self.tr('Error')}: {error_details}"
              QgsMessageLog.logMessage(log_msg, DIALOG_LOG_TAG, level=Qgis.Critical)
              QMessageBox.critical(self, self.tr("Load Error"), user_msg)
              try: self.clear_all_inputs(confirm=False)
              except Exception as clear_err: QgsMessageLog.logMessage(f"Error during post-load-error cleanup: {clear_err}", DIALOG_LOG_TAG, level=Qgis.Critical)
              
    # End of load_input_data


# ========================= End of Class Definition =========================